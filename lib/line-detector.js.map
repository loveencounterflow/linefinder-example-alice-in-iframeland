{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/line-detector.coffee"
  ],
  "names": [],
  "mappings": "AAEmE;EAAA;;AAAA,MAAA,aAAA,EAAA,KAAA,EAAA,UAAA,EAAA,GAAA,EAAA;;EACnE,CAAA,CAAE,GAAF,EACE,IADF,EAEE,KAFF,CAAA,GAEkB,OAFlB,EADmE;;;EAMnE,aAAA,GAAgB,QAAA,CAAA,CAAA;AAChB,QAAA,OAAA,EAAA,CAAA,EAAA,GAAA,EAAA;AAAE;IAAA,KAAA,qCAAA;;MACE,OAAO,CAAC,MAAR,CAAA;IADF;AAEA,WAAO;EAHO,EANmD;;;EAYnE,UAAA,GAAa,QAAA,CAAE,UAAF,CAAA;AACb,QAAA,GAAA,EAAA,CAAA,EAAA,GAAA,EAAA;IAAE,aAAA,CAAA;IACA,KAAA,4CAAA;;MACE,GAAA,GAAM,QAAQ,CAAC,aAAT,CAAuB,KAAvB;MACN,GAAG,CAAC,SAAS,CAAC,GAAd,CAAmB,KAAnB;MACA,GAAG,CAAC,KAAK,CAAC,GAAV,GAAoB,SAAS,CAAC,CAAV,GAAc;MAClC,GAAG,CAAC,KAAK,CAAC,IAAV,GAAoB,SAAS,CAAC,CAAV,GAAc;MAClC,GAAG,CAAC,KAAK,CAAC,KAAV,GAAoB,SAAS,CAAC,KAAV,GAAkB;MACtC,GAAG,CAAC,KAAK,CAAC,MAAV,GAAoB,SAAS,CAAC,MAAV,GAAmB;MACvC,QAAQ,CAAC,IAAI,CAAC,WAAd,CAA0B,GAA1B;IAPF;AAQA,WAAO;EAVI,EAZsD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiGnE,CAAC,CAAC,GAAG,CAAC,KAAN,CAAY,QAAA,CAAA,CAAA;AACZ,QAAA,EAAA,EAAA,EAAA,EAAA,KAAA,EAAA,CAAA,EAAA,EAAA,EAAA;IAAE,GAAA,CAAI,SAAJ,EAAe,OAAf,EAAF;;;IAGE,EAAA,GAAK;IACL,CAAA,GAAI,CAAE,CAAC,CAAC,GAAG,CAAC,UAAN,CAAiB,GAAjB,CAAF,CAAwB,CAAE,CAAF,CAAK,CAAC,UAAU,CAAE,CAAF;IAC5C,EAAA,GAAK,IAAI,MAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAC,CAAC,IAApB,EALP;;IAOE,EAAA,GAAK,IAAI,MAAJ,CAAY,CAAZ,EAAe,EAAf,EAAmB,CAAC,CAAC,IAArB,EAPP;;IASE,YAAY,CAAC,YAAb,CAA2B,EAA3B,EAA+B,EAA/B,EATF;;IAWE,KAAA,GAAQ;IACR,CAAA,GAAI,QAAA,CAAA,CAAA;MACF,YAAY,CAAC,WAAb,CAAyB,EAAzB,EAA4B,EAA5B,EAA+B,EAA/B,EAAkC,IAAlC;MACA,YAAY,CAAC,YAAb,CAA2B,EAA3B,EAA+B,EAA/B;MACA,IAAe,KAAA,GAAQ,IAAvB;AAAA,eAAO,KAAP;;aACA,UAAA,CAAW,CAAX,EAAc,EAAd;IAJE;IAKJ,CAAA,CAAA,EAjBF;;AAmBE,WAAO;EApBG,CAAZ;AAjGmE",
  "sourcesContent": [
    "\n#-----------------------------------------------------------------------------------------------------------\n# source_elements = ( document.querySelector '.sample' ).childNodes\n{ log\n  warn\n  debug }       = console\n\n#-----------------------------------------------------------------------------------------------------------\n_remove_boxes = ->\n  for element in document.querySelectorAll '.box'\n    element.remove()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\ndraw_boxes = ( rectangles ) ->\n  _remove_boxes()\n  for rectangle in rectangles\n    box = document.createElement \"div\"\n    box.classList.add( \"box\" )\n    box.style.top     = rectangle.y + \"px\"\n    box.style.left    = rectangle.x + \"px\"\n    box.style.width   = rectangle.width + \"px\"\n    box.style.height  = rectangle.height + \"px\"\n    document.body.appendChild box\n  return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# collapse_ws = ( value ) -> value.trim().replace /\\s+/g, ' '\n\n# #-----------------------------------------------------------------------------------------------------------\n# extract_lines_from_text_node = ( text_node ) ->\n#   unless text_node.nodeType is 3\n#     throw new Error \"Lines can only be extracted from text nodes.\"\n#   #.........................................................................................................\n#   # A Range represents a fragment of the document which contains nodes and\n#   # parts of text nodes. One thing that's really cool about a Range is that we\n#   # can access the bounding boxes that contain the contents of the Range. By\n#   # incrementally adding characters - from our text node - into the range, and\n#   # then looking at the Range's client rectangles, we can determine which\n#   # characters belong in which rendered line.\n#   textContent     = text_node.textContent\n#   range           = document.createRange()\n#   lines           = []\n#   line_chrs       = []\n#   #.........................................................................................................\n#   # Iterate over every character in the text node.\n#   for chr_idx in [ 0 ... textContent.length ]\n#     # Set the range to span from the beginning of the text node up to and\n#     # including the current character (offset).\n#     range.setStart  text_node, 0\n#     range.setEnd    text_node, chr_idx + 1\n#     # At this point, the Range's client rectangles will include a rectangle\n#     # for each visually-rendered line of text. Which means, the last\n#     # character in our Range (the current character in our for-loop) will be\n#     # the last character in the last line of text (in our Range). As such, we\n#     # can use the current rectangle count to determine the line of text.\n#     line_idx = range.getClientRects().length - 1\n#     # If this is the first character in this line, create a new buffer for this line.\n#     unless lines[ line_idx ]?\n#       line_chrs = []\n#       lines.push line_chrs\n#     # Add this character to the currently pending line of text.\n#     line_chrs.push textContent.charAt chr_idx\n#   lines = ( chrs.join '' for chrs in lines )\n#   draw_boxes range.getClientRects()\n#   return lines\n\n# #-----------------------------------------------------------------------------------------------------------\n# button.addEventListener 'click', ( event ) ->\n#   console.group \"Rendered Lines of Text\"\n#   for source_element in source_elements\n#     console.group \"Element\"\n#     console.log source_element\n#     for line, idx in extract_lines_from_text_node source_element\n#       console.log idx + 1, line\n#   console.groupEnd()\n#   return null\n\n# justify_my_text = ->\n#   console.group \"Unjustifiable\"\n#   # hyph      = new Hypher 'en-us'\n#   hyphenate = ( word ) ->\n#     log '^2342^', word\n#     # hyph.hyphenate word\n#     return Array.from word\n#   cfg       =\n#     hyphenator:     hyphenate\n#     hyphenPenalty:  10\n#   justify   = unjustifiable cfg\n#   for source_element in document.querySelectorAll 'galley > p'\n#     log source_element\n#     try justify source_element catch error\n#       warn error.message\n#     # for line, idx in extract_lines_from_text_node source_element\n#     #   console.log idx + 1, line\n#   console.groupEnd()\n#   return null\n\n#===========================================================================================================\nµ.DOM.ready ->\n  log '^123-7^', \"ready\"\n  # ( µ.DOM.select_first 'button' ).addEventListener 'click', justify_my_text\n  # justify_my_text()\n  nc = []\n  p = ( µ.DOM.select_all 'p' )[ 1 ].childNodes[ 0 ]\n  c1 = new Cursor( p, 0, p.data )\n  # Cursor {node: text, index: 0, text: 'An unimaginably excruciatingly detailed unimaginab…unimaginably excruciatingly\\n  detailed expression'}\n  c2 = new Cursor( p, 20, p.data )\n  # Cursor {node: text, index: 20, text: 'An unimaginably excruciatingly detailed unimaginab…unimaginably excruciatingly\\n  detailed expression'}\n  TraverseUtil.setSelection( c1, c2 )\n  # Selection {anchorNode: text, anchorOffset: 0, focusNode: text, focusOffset: 20, isCollapsed: false, …}\n  count = 0\n  f = ->\n    TraverseUtil.getNextChar(c1,c2,nc,true)\n    TraverseUtil.setSelection( c1, c2 )\n    return null if count > 1000\n    setTimeout f, 20\n  f()\n  # log nc\n  return null\n\n\n\n\n\n\n"
  ]
}