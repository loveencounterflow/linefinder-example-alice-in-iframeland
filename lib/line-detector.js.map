{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/line-detector.coffee"
  ],
  "names": [],
  "mappings": "AAEmE;EAAA;;AAAA,MAAA,KAAA,EAAA,QAAA,EAAA,UAAA,EAAA,GAAA,EAAA,YAAA,EAAA;;EACnE,CAAA,CAAE,GAAF,EACE,IADF,EAEE,KAFF,CAAA,GAEkB,OAFlB,EADmE;;;EAMnE,YAAA,GAAe,QAAA,CAAA,CAAA;AACf,QAAA,OAAA,EAAA,CAAA,EAAA,GAAA,EAAA;AAAE;IAAA,KAAA,qCAAA;;MAAA,OAAO,CAAC,MAAR,CAAA;IAAA;AACA,WAAO;EAFM,EANoD;;;EAWnE,UAAA,GAAa,QAAA,CAAE,UAAF,CAAA;AACb,QAAA,CAAA,EAAA,GAAA,EAAA;IAAE,KAAA,4CAAA;;MAAA,QAAA,CAAS,SAAT;IAAA;AACA,WAAO;EAFI,EAXsD;;;EAgBnE,QAAA,GAAW,QAAA,CAAE,SAAF,CAAA;AACX,QAAA;IAAE,GAAA,GAAoB,QAAQ,CAAC,aAAT,CAAuB,KAAvB;IACpB,GAAG,CAAC,KAAK,CAAC,GAAV,GAAoB,QAAQ,CAAC,eAAe,CAAC,SAAzB,GAAsC,SAAS,CAAC,CAAhD,GAA0D;IAC9E,GAAG,CAAC,KAAK,CAAC,IAAV,GAAoB,QAAQ,CAAC,eAAe,CAAC,UAAzB,GAAsC,SAAS,CAAC,CAAhD,GAA0D;IAC9E,GAAG,CAAC,KAAK,CAAC,KAAV,GAA0D,SAAS,CAAC,KAAV,GAAkB,CAAlB,GAAwB,KAHpF;IAIE,GAAG,CAAC,KAAK,CAAC,MAAV,GAA0D,SAAS,CAAC,MAAV,GAAoB;IAC9E,GAAG,CAAC,SAAS,CAAC,GAAd,CAAkB,KAAlB;IACA,QAAQ,CAAC,IAAI,CAAC,WAAd,CAA0B,GAA1B;AACA,WAAO;EARE,EAhBwD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAmGnE,CAAC,CAAC,GAAG,CAAC,KAAN,CAAY,QAAA,CAAA,CAAA;AACZ,QAAA,EAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,EAAA,CAAA,EAAA,KAAA,EAAA,UAAA,EAAA;IAAE,GAAA,CAAI,SAAJ,EAAe,OAAf,EAAF;;;IAGE,EAAA,GAAK;IACL,CAAA,GAAI,CAAE,CAAC,CAAC,GAAG,CAAC,UAAN,CAAiB,GAAjB,CAAF,CAAwB,CAAE,CAAF,CAAK,CAAC,UAAU,CAAE,CAAF;IAC5C,EAAA,GAAK,IAAI,MAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAC,CAAC,IAApB,EALP;;IAOE,EAAA,GAAK,IAAI,MAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAC,CAAC,IAApB,EAPP;;IASE,YAAY,CAAC,YAAb,CAA2B,EAA3B,EAA+B,EAA/B,EATF;;IAWE,KAAA,GAAQ;IACR,OAAO,CAAC,IAAR,CAAA;AACA,WAAA,IAAA;MACE,KAAA;MACA,YAAY,CAAC,WAAb,CAAyB,EAAzB,EAA6B,EAA7B,EAAiC,EAAjC,EAAqC,KAArC;MACA,SAAA,GAAc,YAAY,CAAC,YAAb,CAA0B,EAA1B,EAA8B,EAA9B;MACd,KAAA,GAAc,SAAS,CAAC,UAAV,CAAqB,CAArB;MACd,UAAA,GAAc,KAAK,CAAC,cAAN,CAAA,EAJlB;;;MAOI,UAAA,CAAW,UAAX;MACA,IAAS,KAAA,GAAQ,IAAjB;AAAA,cAAA;;IATF;IAUA,OAAO,CAAC,OAAR,CAAA,EAvBF;;AAyBE,WAAO;EA1BG,CAAZ;AAnGmE",
  "sourcesContent": [
    "\n#-----------------------------------------------------------------------------------------------------------\n# source_elements = ( document.querySelector '.sample' ).childNodes\n{ log\n  warn\n  debug }       = console\n\n#-----------------------------------------------------------------------------------------------------------\nremove_boxes = ->\n  element.remove() for element in document.querySelectorAll '.box'\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\ndraw_boxes = ( rectangles ) ->\n  draw_box rectangle for rectangle in rectangles\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\ndraw_box = ( rectangle ) ->\n  box               = document.createElement 'div'\n  box.style.top     = document.documentElement.scrollTop  + rectangle.y       + 'px'\n  box.style.left    = document.documentElement.scrollLeft + rectangle.x       + 'px'\n  box.style.width   =                                       rectangle.width - 1   + 'px' # collapse borders\n  box.style.height  =                                       rectangle.height  + 'px'\n  box.classList.add 'box'\n  document.body.appendChild box\n  return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# collapse_ws = ( value ) -> value.trim().replace /\\s+/g, ' '\n\n# #-----------------------------------------------------------------------------------------------------------\n# extract_lines_from_text_node = ( text_node ) ->\n#   unless text_node.nodeType is 3\n#     throw new Error \"Lines can only be extracted from text nodes.\"\n#   #.........................................................................................................\n#   # A Range represents a fragment of the document which contains nodes and\n#   # parts of text nodes. One thing that's really cool about a Range is that we\n#   # can access the bounding boxes that contain the contents of the Range. By\n#   # incrementally adding characters - from our text node - into the range, and\n#   # then looking at the Range's client rectangles, we can determine which\n#   # characters belong in which rendered line.\n#   textContent     = text_node.textContent\n#   range           = document.createRange()\n#   lines           = []\n#   line_chrs       = []\n#   #.........................................................................................................\n#   # Iterate over every character in the text node.\n#   for chr_idx in [ 0 ... textContent.length ]\n#     # Set the range to span from the beginning of the text node up to and\n#     # including the current character (offset).\n#     range.setStart  text_node, 0\n#     range.setEnd    text_node, chr_idx + 1\n#     # At this point, the Range's client rectangles will include a rectangle\n#     # for each visually-rendered line of text. Which means, the last\n#     # character in our Range (the current character in our for-loop) will be\n#     # the last character in the last line of text (in our Range). As such, we\n#     # can use the current rectangle count to determine the line of text.\n#     line_idx = range.getClientRects().length - 1\n#     # If this is the first character in this line, create a new buffer for this line.\n#     unless lines[ line_idx ]?\n#       line_chrs = []\n#       lines.push line_chrs\n#     # Add this character to the currently pending line of text.\n#     line_chrs.push textContent.charAt chr_idx\n#   lines = ( chrs.join '' for chrs in lines )\n#   draw_boxes range.getClientRects()\n#   return lines\n\n# #-----------------------------------------------------------------------------------------------------------\n# button.addEventListener 'click', ( event ) ->\n#   console.group \"Rendered Lines of Text\"\n#   for source_element in source_elements\n#     console.group \"Element\"\n#     console.log source_element\n#     for line, idx in extract_lines_from_text_node source_element\n#       console.log idx + 1, line\n#   console.groupEnd()\n#   return null\n\n# justify_my_text = ->\n#   console.group \"Unjustifiable\"\n#   # hyph      = new Hypher 'en-us'\n#   hyphenate = ( word ) ->\n#     log '^2342^', word\n#     # hyph.hyphenate word\n#     return Array.from word\n#   cfg       =\n#     hyphenator:     hyphenate\n#     hyphenPenalty:  10\n#   justify   = unjustifiable cfg\n#   for source_element in document.querySelectorAll 'galley > p'\n#     log source_element\n#     try justify source_element catch error\n#       warn error.message\n#     # for line, idx in extract_lines_from_text_node source_element\n#     #   console.log idx + 1, line\n#   console.groupEnd()\n#   return null\n\n#===========================================================================================================\nµ.DOM.ready ->\n  log '^123-7^', \"ready\"\n  # ( µ.DOM.select_first 'button' ).addEventListener 'click', justify_my_text\n  # justify_my_text()\n  nc = []\n  p = ( µ.DOM.select_all 'p' )[ 1 ].childNodes[ 0 ]\n  c1 = new Cursor( p, 0, p.data )\n  # Cursor {node: text, index: 0, text: 'An unimaginably excruciatingly detailed unimaginab…unimaginably excruciatingly\\n  detailed expression'}\n  c2 = new Cursor( p, 0, p.data )\n  # Cursor {node: text, index: 20, text: 'An unimaginably excruciatingly detailed unimaginab…unimaginably excruciatingly\\n  detailed expression'}\n  TraverseUtil.setSelection( c1, c2 )\n  # Selection {anchorNode: text, anchorOffset: 0, focusNode: text, focusOffset: 20, isCollapsed: false, …}\n  count = 0\n  console.time()\n  loop\n    count++\n    TraverseUtil.getNextChar c1, c2, nc, false\n    selection   = TraverseUtil.setSelection c1, c2\n    range       = selection.getRangeAt 0\n    rectangles  = range.getClientRects()\n    # debug '^2432^', range.getBoundingClientRect()\n    # draw_box range.getBoundingClientRect()\n    draw_boxes rectangles\n    break if count > 1000\n  console.timeEnd()\n  # log nc\n  return null\n\n\n\n\n\n\n"
  ]
}